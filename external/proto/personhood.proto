syntax = "proto2";
package personhood;

import "darc.proto";
import "byzcoin.proto";

option java_package = "ch.epfl.dedis.lib.proto";
option java_outer_classname = "Personhood";

// LinkPoP stores a link to a pop-party to accept this configuration. It will
// try to create an account to receive payments from clients.
message LinkPoP {
  required Party party = 1;
}

// Party represents everything necessary to find a party in the ledger.
message Party {
  // ByzCoinID represents the ledger where the pop-party is stored.
  required bytes byzcoinid = 1;
  // InstanceID is where to find the party in the ledger.
  required bytes instanceid = 2;
  // FinalStatement describes the party and the signature of the organizers.
  required FinalStatement finalstatement = 3;
  // Darc being responsible for the PartyInstance.
  required darc.Darc darc = 4;
  // Signer can call Invoke on the PartyInstance.
  required darc.Signer signer = 5;
}

// StringReply can be used by all calls that need a string to be returned
// to the caller.
message StringReply {
  required string reply = 1;
}

//
// * Questionnaires
//

// Questionnaire represents one poll that will be sent to candidates.
message Questionnaire {
  // Title of the poll
  required string title = 1;
  // Questions is a slice of texts that will be presented
  repeated string questions = 2;
  // Replies indicates how many answers the player can chose.
  required sint32 replies = 3;
  // Balance left for that questionnaire
  required uint64 balance = 4;
  // Reward for replying to one questionnaire
  required uint64 reward = 5;
  // ID is a random identifier of that questionnaire
  required bytes id = 6;
}

// Reply holds the results of the questionnaire together with a slice of users
// that participated in it.
message Reply {
  // Sum is the sum of all replies for a given index of the questions.
  repeated sint32 sum = 1 [packed=true];
  // TODO: replace this with a linkable ring signature
  repeated bytes users = 2;
}

// RegisterQuestionnaire creates a questionnaire with a number of questions to
// chose from and how much each replier gets rewarded.
message RegisterQuestionnaire {
  // Questionnaire is the questionnaire to be stored.
  required Questionnaire questionnaire = 1;
}

// ListQuestionnaires requests all questionnaires from Start, but not more than
// Number.
message ListQuestionnaires {
  // Start of the answer.
  required sint32 start = 1;
  // Number is the maximum of questionnaires that will be returned.
  required sint32 number = 2;
}

// ListQuestionnairesReply is a slice of all questionnaires, starting with the
// one having the highest balance left.
message ListQuestionnairesReply {
  // Questionnaires is a slice of questionnaires, with the highest balance first.
  repeated Questionnaire questionnaires = 1;
}

// AnswerQuestionnaire sends the answer from one client.
message AnswerQuestionnaire {
  // QuestID is the ID of the questionnaire to be replied.
  required bytes questid = 1;
  // Replies is a slice of answers, up to Questionnaire.Replies
  repeated sint32 replies = 2 [packed=true];
  // Account where to put the reward to.
  required bytes account = 3;
}

// TopupQuestionnaire can be used to add new balance to a questionnaire.
message TopupQuestionnaire {
  // QuestID indicates which questionnaire
  required bytes questid = 1;
  // Topup is the amount of coins to put there.
  required uint64 topup = 2;
}

//
// * Popper
//

// Message represents a message that will be sent to the system.
message Message {
  // Subject is one of the fields always visible, even if the client did not
  // chose to read the message.
  required string subject = 1;
  // Date, as unix-encoded seconds since 1970.
  required uint64 date = 2;
  // Text, can be any length of text of the message.
  required string text = 3;
  // Author's coin account for eventual rewards/tips to the author.
  required bytes author = 4;
  // Balance the message has currently left.
  required uint64 balance = 5;
  // Reward for reading this messgae.
  required uint64 reward = 6;
  // ID of the messgae - should be random.
  required bytes id = 7;
  // PartyIID - the instance ID of the party this message belongs to
  required bytes partyiid = 8;
}

// SendMessage stores the message in the system.
message SendMessage {
  // Message to store.
  required Message message = 1;
}

// ListMessages sorts all messages by balance and sends back the messages from
// Start, but not more than Number.
message ListMessages {
  // Start of the messages returned
  required sint32 start = 1;
  // Number of maximum messages returned
  required sint32 number = 2;
  // ReaderID of the reading account, to skip messages created by this reader
  required bytes readerid = 3;
}

// ListMessagesReply returns the subjects, IDs, balances and rewards of the top
// messages, as chosen in ListMessages.
message ListMessagesReply {
  // Subjects of the messages
  repeated string subjects = 1;
  // MsgIDs of the messages
  repeated bytes msgids = 2;
  // Balances
  repeated uint64 balances = 3 [packed=true];
  // Rewards
  repeated uint64 rewards = 4 [packed=true];
  // PartyIIDs
  repeated bytes partyiids = 5;
}

// ReadMessage requests the full message and the reward for that message.
message ReadMessage {
  // MsgID to request.
  required bytes msgid = 1;
  // PartyIID to calculate the party coin account
  required bytes partyiid = 2;
  // Reader that will receive the reward
  required bytes reader = 3;
}

// ReadMessageReply if the message is still active (balance >= reward)
message ReadMessageReply {
  // Messsage to read.
  required Message message = 1;
  // Rewarded is true if this is the first time the message has been read
  // by this reader.
  required bool rewarded = 2;
}

// TopupMessage to fill up the balance of a message
message TopupMessage {
  // MsgID of the message to top up
  required bytes msgid = 1;
  // Amount to coins to put in the message
  required uint64 amount = 2;
}

// TestStore is used to store test-structures. If it is called
// with null pointers, nothing is stored, and only the currently
// stored data is returned.
// This will not be saved to disk.
message TestStore {
  optional bytes byzcoinid = 1;
  optional bytes spawneriid = 2;
}

// CredentialStruct holds a slice of credentials.
message CredentialStruct {
  repeated Credential credentials = 1;
}

// Credential represents one identity of the user.
message Credential {
  required string name = 1;
  repeated Attribute attributes = 2;
}

// Attribute stores one specific attribute of a credential.
message Attribute {
  required string name = 1;
  required bytes value = 2;
}

// SpawnerStruct holds the data necessary for knowing how much spawning
// of a certain contract costs.
message SpawnerStruct {
  required byzcoin.Coin costdarc = 1;
  required byzcoin.Coin costcoin = 2;
  required byzcoin.Coin costcredential = 3;
  required byzcoin.Coin costparty = 4;
  required bytes beneficiary = 5;
}

// PopPartyStruct is the data that is stored in a pop-party instance.
message PopPartyStruct {
  // State has one of the following values:
  // 1: it is a configuration only
  // 2: scanning in progress
  // 3: it is a finalized pop-party
  required sint32 state = 1;
  // Organizers is the number of organizers responsible for this party
  required sint32 organizers = 2;
  // Finalizations is a slice of organizer-darcIDs who agree on the list of
  // public keys in the FinalStatement.
  repeated darc.ID finalizations = 3;
  // Description holds the name, date and location of the party and is available
  // before the barrier point.
  required PopDesc description = 4;
  // Attendees is the slice of public keys of all confirmed attendees
  required Attendees attendees = 5;
  // Miners holds all tags of the linkable ring signatures that already
  // mined this party.
  repeated LRSTag miners = 6;
  // How much money to mine
  required uint64 miningreward = 7;
  // Previous is the link to the instanceID of the previous party, it can be
  // nil for the first party.
  required bytes previous = 8;
  // Next is a link to the instanceID of the next party. It can be
  // nil if there is no next party.
  required bytes next = 9;
}

// PopDesc holds the name, date and a roster of all involved conodes.
message PopDesc {
  // Name of the party.
  required string name = 1;
  // Purpose of the party
  required string purpose = 2;
  // DateTime of the party. It is stored as seconds since the Unix-epoch, 1/1/1970
  required uint64 datetime = 3;
  // Location of the party
  required string location = 4;
}

// FinalStatement is the final configuration holding all data necessary
// for a verifier.
message FinalStatement {
  // Desc is the description of the pop-party.
  optional PopDesc desc = 1;
  // Attendees holds a slice of all public keys of the attendees.
  required Attendees attendees = 2;
}

// Attendees is a slice of points of attendees' public keys.
message Attendees {
  repeated bytes keys = 1;
}

// LRSTag is the tag of the linkable ring signature sent in by a user.
message LRSTag {
  required bytes tag = 1;
}
