syntax = "proto2";
package ocs;
import "onet.proto";

option java_package = "ch.epfl.dedis.lib.proto";
option java_outer_classname = "OCS";

// ***
// API calls
// ***

// CreateOCS is sent to the service to request a new OCS cothority.
message CreateOCS {
  required onet.Roster roster = 1;
  required Policy policy = 2;
}

// CreateOCSReply is the reply sent by the conode if the OCS has been
// setup correctly. It contains the ID of the OCS, which is the binary
// representation of the aggregate public key. It also has the Sig, which
// is the collective signature of all nodes on the aggregate public key
// and the authentication.
message CreateOCSReply {
  required bytes x = 1;
  required bytes sig = 2;
}

// Reencrypt is sent to the service to request a re-encryption of the
// secret given in AuthReencrypt. AuthReencrypt must also contain the proof that the
// request is valid, as well as the ephemeral key, to which the secret
// will be re-encrypted.
message Reencrypt {
  required bytes x = 1;
  required AuthReencrypt auth = 2;
}

// MessageReencryptReply is the reply if the re-encryption is successful, and
// it contains XHat, which is the secret re-encrypted to the ephemeral
// key given in AuthReencrypt.
message ReencryptReply {
  required bytes xhat = 1;
}

// Reshare is called to ask OCS to change the roster. It needs a valid
// authentication before the private keys are re-generated over the new
// roster.
message Reshare {
  required bytes x = 1;
  required onet.Roster newroster = 2;
  required AuthReshare auth = 3;
}

// ReshareReply is returned if the resharing has been completed successfully
// and contains the collective signature on the message
//   sha256( X | NewRoster )
message ReshareReply {
  required bytes sig = 1;
}

// ***
// Common structures
// ***

// PolicyOCS holds the two policies necessary to define an OCS: how to
// authenticate a reencryption request, and how to authenticate a
// resharing request.
// In the current form, both policies point to the same structure. If at
// a later moment a new access control backend is added, it might be that
// the policies will differ for this new backend.
message PolicyOCS {
  required Policy policyreencrypt = 1;
  required Policy policyreshare = 2;
}

// Policy holds all possible authentication structures. When using it to call
// Authorise, only one of the fields must be non-nil.
message Policy {
  optional PolicyByzCoin byzcoin = 1;
  optional PolicyX509Cert authx509cert = 2;
}

// PolicyByzCoin holds the information necessary to authenticate a byzcoin request.
// In the ByzCoin model, all requests are valid as long as they are stored in the
// blockchain with the given ID.
// The TTL is to avoid that too old requests are re-used. If it is 0, it is disabled.
message PolicyByzCoin {
  required bytes byzcoinid = 1;
  required uint64 ttl = 2;
}

// PolicyX509Cert holds the information necessary to authenticate a HyperLedger/Fabric
// request. In its simplest form, it is simply the CA that will have to sign the
// certificates of the requesters.
// The Threshold indicates how many clients must have signed the request before it
// is accepted.
message PolicyX509Cert {
  // Slice of ASN.1 encoded X509 certificates.
  repeated bytes ca = 1;
  required sint32 threshold = 2;
}

// AuthReencrypt holds one of the possible authentication proofs for a reencryption request. Each
// authentication proof must hold the secret to be reencrypted, the ephemeral key, as well
// as the proof itself that the request is valid. For each of the authentication
// schemes, this proof will be different.
message AuthReencrypt {
  optional AuthReencryptByzCoin byzcoin = 1;
  optional AuthReencryptX509Cert x509cert = 2;
}

// AuthReencryptByzCoin holds the proof of the write instance, holding the secret itself.
// The proof of the read instance holds the ephemeral key. Both proofs can be
// verified using one of the stored ByzCoinIDs.
message AuthReencryptByzCoin {
  // Write is the proof containing the write request.
  required bytes write = 1;
  // Read is the proof that he has been accepted to read the secret.
  required bytes read = 2;
}

// AuthReencryptX509Cert holds the proof that at least a threshold number of clients
// accepted the reencryption.
// For each client, there must exist a certificate that can be verified by the
// CA certificate from PolicyX509Cert. Additionally, each client must sign the
// following message:
//   sha256( Secret | Ephemeral | Time )
message AuthReencryptX509Cert {
  required bytes secret = 1;
  repeated bytes certificates = 2;
}

// AuthReshare holds the proof that at least a threshold number of clients accepted the
// request to reshare the secret key. The authentication must hold the new roster, as
// well as the proof that the new roster should be applied to a given OCS.
message AuthReshare {
  optional AuthReshareByzCoin byzcoin = 1;
  optional AuthReshareX509Cert x509cert = 2;
}

// AuthReshareByzCoin holds the byzcoin-proof that contains the latest OCS-instance
// which includes the roster. The OCS-nodes will make sure that the version of the
// OCS-instance is bigger than the current version.
message AuthReshareByzCoin {
  required bytes reshare = 1;
}

// AuthReshareX509Cert holds the X509 proof that the new roster is valid.
message AuthReshareX509Cert {
  repeated bytes certificates = 1;
}
